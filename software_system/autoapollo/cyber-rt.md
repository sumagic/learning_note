## cyber-rt notes

### website link
    1. [cyber框架](https://zhuanlan.zhihu.com/p/91322837)
    2. cyber是一个分布式收发消息和调度框架，同时对外提供一系列的工具和接口来辅助开发和定位问题。
    3. cyber相比ROS来说有很多优势，唯一的恶劣就是cyber相对ROS没有丰富的算法库支持

### cyber入口
    1. cyber/mainboard中
    '''c++
    ├── mainboard.cc           // 主函数
    ├── module_argument.cc     // 模块输入参数
    ├── module_argument.h
    ├── module_controller.cc   // 模块加载，卸载
    └── module_controller.h
    '''
    2. 

### cyber RT学习
* [apollo cyber rt操作系统学习记录](https://blog.csdn.net/jinfagang1211/article/details/87198285)
<img src="../data/img/cyberrt-architecture.png">cyberrt架构</img>
* cyberRT最底层的是一些apollo内部使用的库，为了减少依赖，提高整个系统的效率，许多轮子自己造。比如他们自己实现的高效率的FreeList对象回收池；
* 再往上是通信相关的，包括服务发现，publish-subscribe通信机制。CyberRT也支持跨进程、跨机器通信，上层业务逻辑无需关心，通信层会根据算法模块的部署，自动选择相应通信机制
* 通信层之上是数据缓存/融合层，多路传感器之间数据需要融合，而且算法可能需要缓存一定的数据。数据层起到了这个模块间通信桥梁的作用。
* 再往上是计算层，计算模型包括刚才前面提到的调度和任务。
* 计算模型之上是为开发者提供的借口。cyber rt为开发者提供了component类，开发者的算法业务模块只需要继承该类，实现其中的proc接口即可。cyberrt基于协程，为开发者提供了并行计算相关的接口
* cyberrt中另外一个比较重要的创新就是，改变了ROS里面的调度顺序，或者说ROS里面其实并没有调度，完全依赖于系统，此时就会导致系统负载过多过乱，cyberrt再这个基础之上引入自建调度体系，这是一个十分重要创新。
* apollo里面讲算法搭载再协程之上，是轻量化的线程。现成是进程下面的多个并行化的任务，线程与线程之间的通信必须通过信道进行，而协程可以直接通过访问全局变量来进行协程之间的通信。具体如何搭载要看代码实现和分析了。
* 通信层智商的数据缓存/融合层，不同算法模块之间需要一个数据桥梁，数据层起到了这个模块间通信的桥梁的作用。

### cyberrt源码分析
* cyberrt的实现是模块化的，重要的就是component和croutine两个模块，后者是自己实现的一个高性能的协程库，为整个系统提供协程的调用。

##### ros存在哪些问题
* 烦人的master，由于master的存在，导致每次的ros工程都要启动master节点，一旦master挂机了，其他节点都GG;
* ros内部没有调度，完全依赖于操作系统，所以进程之间没有优先性，这回导致一些重要的节点有时候会由于其他非重要节点的抢占而卡顿，二有时候他们的卡顿是致命的。
* cyber是框架，也就是调度的东西，所有的节点都变成了modules，也就是模块

## cyberrt架构
* [cyberrt架构](https://blog.csdn.net/qq_25762163/article/details/103591766)

## 调度
* 将调度、任务从内核空间放到了用户空间，在原生的thread上加了一层协程(Coroutine)，cyberRT主要调度的就是协程。
* 调度编排策略很好的结合了业务逻辑，数据共享和算力的平衡，并且任务不会再不同CPU上随机的调度来调度去，具有非常好的Cache友好性。通过对队列减少并发瓶颈，并且集成了一些独占的策略。
* 从cyber rt角度，os的native thread相当于物理CPU
* 在OS中，是内核中的调度器负责调度任务(进程、线程...)到物理CPU上运行，而在cyber rt中，cyber rt中的调度器调度协程再native thread上有序运行。
* 每个processor一个任务队列，由调度器编排队列中的任务
* 任务在哪个CPU上运行，任务之间是否需要相邻运行，哪些先运行，哪些后运行，由调度器统一调度
* 任务基于协程实现，再任务阻塞时，快速让出CPU
* 每个物理CPU上除了运行一个normal级别的thread外，运行着另外1+个高优先级的thread,基于此实现用户空间的高优先级的任务抢占运行
* cache friendly

## 调度——经典策略
* 经典的线程池模式
* 多个优先级队列，支持任务划分优先级，减少并发瓶颈
* 抽象的任务组，除了优先级外，考虑耕读哟资源限制因素，比如某个任务组仅能使用哪些CPU，占用cpu的Quota等等
* cyber rt调度器调度有状态的协程再各个线层上运行，现成不仅切换快，而且调度有着高确定性，不像线程的调度完全依赖操作系统

## 算法任务载体——协程
* 上层业务逻辑无需关心，通信层会根据算法模块的部署，自动选择相应通信机制

## 百度apollo学习系统-CyberRT注册启动模块
* [link](https://blog.csdn.net/qq_25762163/article/details/103669467)
* cyber是ROS的一个替代品，因此我们可以先弄明白cyber到底做了什么，同ROS一样，cyber的主要作用就是一个消息中间件，他们需要管理不同的模块，并让他们互相之间可以高效通信。
* 作者希望让读者真正理解cyber如何管理一个个模块，对自己以后做系统架构或者理解一些大型开源项目都会由帮助

### 代码结构
* cyber rt的代码设计模式是工厂方法模式
* 工厂方法模式就是有两个总的抽象类，一个工厂基类，一个产品基类。每个不同的产品都需要给他实现一个工厂，当我们需要产品的实例时，就就可以调用相应的工厂类返回该产品实例

##### apollo项目中的modules文件夹和module的关系
* cyber/modules里的某一个子文件夹可能对应着多个module，我们一般要加载的模块也就是要把这个module对应的所有component/timercomponent组件给实例化出来。
* 一个动态库对应一个或者多个module，在实例化的时候包含这些组件的动态库必须已经被加载进来了
* 一个dag文件对应一个模块。

* classloader负责的是某个动态库的所有组件的创建和生成。
* cyber rt的模块管理架构的设计还是由很多冗余以及混乱的地方，再一些类和函数的命名上也有问题。因此需要在架构项目的时候可以从一开始就做好规划。

## 百度apollo系统学习-cyber-rt通信上层
* cyber最基础的功能就是解决不同模块不同进程之间的通信问题。
* [cyberrt通信](https://blog.csdn.net/qq_25762163/article/details/103803032)
