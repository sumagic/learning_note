# 从零开始做自动驾驶定位  学习笔记

##  [九](https://zhuanlan.zhihu.com/p/110040883)

* 在里程计计算之前做了时间同步、点云畸变补偿等预处理
* 再里程计计算之后做了实时显示、轨迹精度评测等
* 这种之前和之后的描述已经具备了模块划分的概念，即分成了三个模块
* 在建图功能构面的工作里，我们要添加的就是后端优化、闭环检测这两大模块了
* 这样总共就有了5个模块

### 设计思路

* 需要对每一个模块做一个封装，并把代码文件用合适的目录管理

##### 模块功能详解

###### 数据预处理

* 功能
    [1] 接收各传感器信息
    [2] 传感器数据时间同步
    [3] 点云运动畸变补偿
    [4] 传感器信息统一坐标系
* 输入
    [1] GNSS组合导航未知、姿态、角速度、角加速度等
    [2] 雷达点云数据
    [3] 雷达和IMU相对坐标系
* 输出
    [1] GNSS组合导航位置、姿态
    [2] 畸变补偿后的点云

* 以上信息均是经过时间同步的，时间戳已经保持一致

## [十 后端优化 ](https://zhuanlan.zhihu.com/p/110236521)

* 对一个建图系统来将，有了后端才是有了核心
* 后端通过图优化实现消除累计误差的功能，目前由三个流行的库：g2o, gtsam，ceres
* kitti数据集可用的观测量包括GNSS位置和GNSS姿态两个
* 前端里程计添加观测消除误差，其实就是一个融合，融合后的位姿用来拼接点云。再这样的任务里，对姿态观测准确度的要求要大于对位置观测亮准确度的要求。GNSS组合导航系统中，位置观测往往都是有RTK高精度信息做基础，相对更准确。姿态则是通过导航系统里对位置误差的观测反向推导的，往往精度稍差。

## 闭环修正

* 闭环修正模块是建图功能的最后一个模块
* 接收关键帧位姿以及对应的GNSS位姿，根据策略做检测，如果检测到满足要求的闭环匹配，那么就把这一对约束关系发送出去，让后端优化模块把这个约束关系作为一个边加入到概率图中就行了
* 检测的基本思路就是再历史关键帧中找到离当前关键帧最近的关键帧，并匹配对应的点云，如果匹配误差足够小，那么检测就成功了

###  闭环检测
* 根据当前帧位置从历史帧位置中查找和它距离最近的关键帧时，会面临一系列问题
* 如果历史帧产生时间和当前帧时间差太小，说明者是一个小闭环，意义不大
* 没产生新的关键帧都对历史帧做一次遍历，太消耗时间
* 如果明知道某一端距离内不会有复合条件的历史帧，那么检测就不必要

##### 解决方案如下

* 设置最小时间差，这里的时间差严格来讲是关键帧的路程差,关键帧的变好是随着车的前进顺序递增产生的
* 为避免频繁检测，每检测一次，就做一次等待，通过配置文件设置等待的帧数

##### 点云匹配

* scan-to-map的匹配是不scan-to-scan的匹配更加精确，所以我们不应该把当前帧点云和距离历史帧点云匹配，而应该以该历史帧为中心，按照时间往前和往后各索引几个关键帧，拼接成一个小地图。

### 闭环检测要不要加上

* 它作为约束，能够消除部分累计误差，但不是全部
* 它能够消除点云地图重影
* 对于没有外界先验信息作为约束的场景，笔记gnss等检测到的位姿。没有约束信息的往往是室内场景。 它把开环里所建的不闭合的地图闭合了，同时消除了部分误差，所以必然是要加的
* 对于有先验信息参考约束的场景，gnss的RTK精度确实很高，但是如果我们经常用只加gnss，比闭环的方案建图时，会发现再采集车辆重复经过的区域里，会由重影。此时闭环再这里根本就不是用来提高精度的，而是用来去除重影的


##  前端里程计的扩展
* 所谓扩展性，就是每一个功能模块都可以随意更换

## [十三](https://zhuanlan.zhihu.com/p/110714776)

* 定位方案设计的核心其实就三个字：互补性
* 定位方案中传感器的选择的过程，其实就是寻找互补性的过程；而融合的过程，就是执行互补性的过程
* IMU和GNSS： IMU由累计误差，但是没有位姿跳变；GNSS没有累计误差，但是收到干扰或者遮挡时会发生跳变。
* GNSS和点云地图定位，二者都不随时间累计，均由位姿跳变，前者再场景稀疏的情况下定位很好，后者再空旷处无法定位，二者融合，两种场景都可以解决
* 只有差异性才能在融合中得到补偿
* 通过融合消除误差的过程，就是为该误差寻找差异性信息的过程
* 状态估计的过程，就是理解传感器本质的过程
* 系统性能的短板是由最缺失的那个差异性来决定给的

## [第十四讲 定位](https://zhuanlan.zhihu.com/p/111099844)

* 定位其实就一句话，把当前点云和地图做匹配

### 需要考虑几个问题

* 由于地图比较大，所以加载地图之后需要做一个滤波
* 由于匹配需要初始位置，所以要做初始化
* 地图很大，直接加载整张地图很耗费时间，只需要附近的点云就可以了;所以需要从大地图中分割出一个小地图
* 每移动一次就重新分割一次小地图，同样很耗费时间，所以小地图面积可以适当大一些，当车辆快要离开小地图时再重新分割

### 地图加载

* 原始地图是非常大的，地图要经过两次稀疏。第一次是建图模块生成地图的时候，第二次是加载之后，根据定位时局部地图所需要的稀疏读再进行一次滤波
* 位姿初始化，由于建图时是以gnss为基准进行优化的，所以再初始化的时候也把第一帧gnss位姿赋值给匹配算法就可以了
* 完成初始化以后，就可以只使用雷达点云定位，而不需要gnss数据了

### 局部地图分割

* 从全局地图中分割出局部地图采用的是pcl中的CropBox方法，它的基本原理就是从一个大的点云中按照一个长方体尺寸分割出一块小的点云出来

* 局部地图的大小再配置文件中可以设置。参数决定了局部地图分割的频繁程度

## [十五 总结](https://zhuanlan.zhihu.com/p/111123393)

* 手动实现的方法，在这个行业是没有生命力的，自动化是大势所趋。小批量下精度重于效率，但是效率是商业化要求的重中之重。开发人员设计方法时应面向用户考虑问题，而不是只考虑自己省事。
* 用户使用的简单都是我们开发的复杂换来的，不能以复杂、麻烦为里有不去做，这是我们的责任。

