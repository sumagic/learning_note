# ROS_SLAM

## [ROS激光SLAM导航](https://blog.csdn.net/luohuiwu/article/details/92787237)

* gmapping包是ROS里对开元社区openslam下gmapping算法的c++实现，该算法采用一种高效的rao-blackwellized粒子滤波将收取到的激光测距数据最终转换为栅格地图

* 机器人定位与建图通常被认为是鸡与鸡蛋的问题，所以即时定位与地图构建(SLAM)是这样一个概念，把两方面的进程都捆绑在一个循环之中，以此来支持双方在各自进程中都求得连续解；不同进程中相互迭代的反馈对双方的连续解有改进作用

### 粒子滤波器

* 占据栅格地图的构建主要采取***粒子滤波***的方法
* 粒子滤波的思想基于蒙特卡洛方法来表示概率，可以用在任何形式的状态空间模型上
* 粒子滤波的核心思想是通过从后验概率中抽取的随机状态粒子来表达其分布，是一种循序重要性采样法

* 粒子滤波的思想是通过一组粒子来估计近似状态概率。在粒子滤波中，后验分布的样本，我们称之为粒子，每一个粒子都是在时刻t的一个状态的实例化。

##### 粒子滤波的步骤

* 初始化阶段: 规定粒子数量，将粒子平均的分布在规划区域，规划区域需要人为或者通过特征算法计算得出。对于SLAM来说，规划区域一般为用来进行定位的地图，在初始化时，将需要设置的特定数量粒子均匀的洒满整张地图

* 转移阶段： 这个阶段所做的任务就是对每个粒子根据状态转移方程进行状态估计，每个粒子将会产生一个相对应的预测粒子。这一步同卡尔曼滤波方法相同，只是卡尔曼是对一个状态进行状态估计，粒子滤波是对大量样本进行状态估计

* 决策阶段： 也称为校正阶段。在这一阶段中，算法需要对预测粒子进行评价，越接近于真实状态的粒子，其权重越大。此步骤是为重采样作准备。

* 重采样阶段： 根据粒子权重对粒子进行筛选，筛选过程中，需要大量保留权重大的粒子，又要有一小部分权重小的粒子；权重小的粒子有些会被淘汰，为了保证粒子总数保持不便，一般会在权重较高的粒子附近加入一些新的粒子

* 滤波: 将重采样后的粒子带入状态转移方程得到新的预测粒子，然后将他们继续进行上述过程，经过这种循环迭代，最终绝大部分粒子会聚集在与真实值最接近的区域，从而得到机器人准确的位置，实现定位。

* 地图生成： 每个粒子都携带一个路径地图，整个过程下来我们选取最优的粒子，即可获得规划区域的栅格地图

### 导航基本原理

* navigation栈是一个获取里程计信息、传感器数据和目标位姿并输出安全的速度命令

* 定位： 机器人在导航的过程中需要时刻确定自身当前的位置，navigation栈使用amcl包来定位。amcl是一种概率定位系统，以2D方式对移动机器人定位，它实现了自适应蒙特卡洛定位法，使用粒子滤波跟踪机器人在已知地图中的位姿。

* 路径规划，路径导航部分使用move_base包，该包能够获取机器人周围信息并生成全局与局部的代价地图，根据这些代价地图可以使机器人绕开障碍物安全到达指定的位置。move_base的路径规划主要分为全局规划和局部规划，分别是A*算法和DWA算法

* 在激光slam系统中，gmapping获取扫描的激光雷达信息以及里程计数据可动态的生成2D栅格地图。导航包则利用这个栅格地图，里程计数据和激光雷达数据作出适合的路径规划和定位，最后转换为机器人的速度指令。

### 导航系统框架

* 导航系统总结来看可以分为数据收集层，全局规划层，局部规划层，行为层，控制器层
* move_base中的使用


## [ros navigation stack源码学习](https://zhuanlan.zhihu.com/p/28133329)

* ros navigation stack是ros经典的导航包集合，在通过gmapping等方法得到地图后可以实现定位、全局路径规划、动态局部规划等一系列的导航核心功能

* ros navigation导航包一共有17个ros package
* 定位的package需要研究核心算法

### 导航共有三个核心功能

* 定位，acml, adaptive monte carlo localization实现，简单说就是放很多pose，然后估计下哪个pose从地图中看到的跟雷达的数据最符合

* 全局规划

* 局部规划

### navigation源码阅读

* navigation 是ros中实现导航的集(stack)

### 基于ROS的自主导航小车 plantbot导航

* [基于ROS的自主导航小车Plantbot--自主导航](https://zhuanlan.zhihu.com/p/27509134)
* 

##### 粒子滤波: acml

* 了解c++程序最好的方法当然是读取头文件，pf目录可以看到
* 粒子滤波的算法中，核心是计算权重跟重新采样

##### 规划

* acml包研究完了，下面就是规划。规划的基础是地图，所以要先研究costmap_2d这个包

### [navigation stack](https://www.jianshu.com/p/85faa82309b4)

* navigation stack是一个ROS的metapackage
* 里面包含了ROS在路径规划，定位，地图，异常行为恢复等方面的package，
* 主要作用就是路径规划，输入各传感器的数据，输出速度
* 一般我们的ros都预装了navigation

* amcl, 定位
* fake_loalization, 定位
* map_server, 提供地图
* move_base, 路径规划节点
* nav_core, 路径规划的接口类
* base_local_planner, 实现了多个局部路径规划算法
* dwa_local_planner,重新实现了dwa局部规划算法
* parrot_planner, 实现了较为简单的全局规划算法
* navfn, 全局规划算法
* global_planner, 实现了某些全局规划算法
* clear_costmap_recovery，实现了清除代价地图的恢复行为
* rotate_recovery, 实现了旋转的恢复行为
* move_slow_and_clear, 实现了缓慢移动的恢复行为
* costmap_2d, 二维代价地图
* voxel_grid, 三维小方块
* rebot_poase_ekf, 机器人位姿的卡尔满滤波器

### [TF](https://zhuanlan.zhihu.com/p/28288871)

* TF是ROS核心库之一，它记录了所有frame的变换关系
* TF使用起来非常简单，核心函数就有两个，一个broadcast，把坐标变换关系发布出去，一个listener监听所有的broadcast，建立好坐标变换树方便调用
