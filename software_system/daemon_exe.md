# 守护进程总结

* [守护进程](https://blog.csdn.net/coolwriter/article/details/80205647)
* 守护进程是linux的后台的服务进程，是一个生存期较长的进程
* 独立于终端并且周期性的执行某种任务或等待处理某些任务
* 在系统引导时载入时启动，在系统关闭时终止

## 编写守护进程的5个步骤：
### 创建子进程，父进程退出
* 守护进程需要脱离shell终端，造成一种程序关闭的假象，所有的工作都在子进程中完成。
* 创建子进程，父进程退出，会造成子进程成为一个孤儿进程，在linux中当系统发现一个孤儿进程，就会使用1号进程(init进程)收养它。这样子进程就变成了init子进程了。

### 在子进程中创建新会话

* 进程组，就是多个进程，进程组由进程组ID标识，也是一个进程的必备属性，每个进程组都有一个组长进程，组长进程的ID就是进程组的ID。进程ID不会因为组长进程的退出而受到影响

* 会话期，会话组是多个进程组组成的，一个会话开始与用户登录，终止于用户退出，在此期间用户运行的所有进程都属于这个会话期
* setid()-----创建一个新的会话，并担任会话组的组长,具体有3个作用
[1] 让进程摆脱原来会话的控制
[2] 让进程摆脱原来进程组的控制
[3] 让进程摆脱原来的控制终端的控制

* ps: 虽然创建子进程之后父进程退出了，但是子进程复制了父进程的会话期，进程组和控制终端，所以要让子进程完全的独立出来就需要调用setsid()函数，摆脱所有其他进程的控制

### 改变当前目录为根目录

* 由于子进程继承了父进程的当前工作目录，由于再进程运行过程中当前工作目录的文件系统是不能卸载的，因此这会给以后的使用造成麻烦，比如系统需要进入到单用户模式。所以通常的做法是让“/”作为当前目录，当然也可以把当前目录换成其他目录，使用chdir()即可。

### 重设文件权限掩码

* 文件权限掩码是指屏蔽掉文件权限中的对应位，fork()创建的子进程会继承父进程的文件权限掩码。所以如果我们把文件权限掩码设置为0，可以增加子进程的灵活性，使用umask(0)即可
* 关闭文件描述符，子进程会继承父进程的一些已经打开的文件，这些打开的文件可能永远都不会被守护进程读与写。但是它会占用系统资源，而且会导致所在文件系统无法卸载。

## debug
* 守护进程由于完全脱离终端，即使使用gdb也是无法调试的
* 